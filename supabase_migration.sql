-- Create dogs table
CREATE TABLE IF NOT EXISTS dogs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Enable Row Level Security on dogs
ALTER TABLE dogs ENABLE ROW LEVEL SECURITY;

-- Create bookings table
CREATE TABLE IF NOT EXISTS bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  dog_id BIGINT REFERENCES dogs(id) ON DELETE CASCADE NOT NULL,
  start_date DATE NOT NULL,
  start_period TEXT CHECK (start_period IN ('morning', 'evening')) NOT NULL,
  end_date DATE NOT NULL,
  end_period TEXT CHECK (end_period IN ('morning', 'evening')) NOT NULL,
  color TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Enable Row Level Security on bookings
ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;

-- Create a view to check dogs with bookings on specific dates
CREATE OR REPLACE VIEW dogs_with_bookings_by_date AS
SELECT 
  d.id AS dog_id,
  d.name AS dog_name,
  b.id AS booking_id,
  b.start_date,
  b.start_period,
  b.end_date,
  b.end_period
FROM 
  dogs d
JOIN 
  bookings b ON d.id = b.dog_id;

-- Create function to check Auth0 JWT token 
CREATE OR REPLACE FUNCTION auth.get_auth0_role() RETURNS TEXT AS $$
DECLARE
  _role TEXT;
BEGIN
  IF current_setting('request.jwt.claims', true)::json ->> 'role' IS NOT NULL THEN
    _role := current_setting('request.jwt.claims', true)::json ->> 'role';
    RETURN _role;
  END IF;
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to check if authenticated with Auth0
CREATE OR REPLACE FUNCTION auth.is_auth0_authenticated() RETURNS BOOLEAN AS $$
BEGIN
  IF current_setting('request.jwt.claims', true)::json ->> 'sub' IS NOT NULL THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create RLS policies for dogs table
-- Anyone can view dogs
CREATE POLICY "Public can view dogs" ON dogs 
  FOR SELECT USING (true);

-- Only authenticated users can insert, update, or delete dogs
CREATE POLICY "Authenticated users can insert dogs" ON dogs 
  FOR INSERT WITH CHECK (auth.is_auth0_authenticated());

CREATE POLICY "Authenticated users can update dogs" ON dogs 
  FOR UPDATE USING (auth.is_auth0_authenticated());

CREATE POLICY "Authenticated users can delete dogs" ON dogs 
  FOR DELETE USING (auth.is_auth0_authenticated());

-- Create RLS policies for bookings table
-- Anyone can view bookings
CREATE POLICY "Public can view bookings" ON bookings 
  FOR SELECT USING (true);

-- Only authenticated users can insert, update, or delete bookings
CREATE POLICY "Authenticated users can insert bookings" ON bookings 
  FOR INSERT WITH CHECK (auth.is_auth0_authenticated());

CREATE POLICY "Authenticated users can update bookings" ON bookings 
  FOR UPDATE USING (auth.is_auth0_authenticated());

CREATE POLICY "Authenticated users can delete bookings" ON bookings 
  FOR DELETE USING (auth.is_auth0_authenticated());

-- Create indexes for improved query performance
CREATE INDEX IF NOT EXISTS bookings_dog_id_idx ON bookings (dog_id);
CREATE INDEX IF NOT EXISTS bookings_start_date_idx ON bookings (start_date);
CREATE INDEX IF NOT EXISTS bookings_end_date_idx ON bookings (end_date);

-- Create a function to search for dogs with bookings in a date range
CREATE OR REPLACE FUNCTION get_dogs_with_bookings_in_period(start_date DATE, end_date DATE)
RETURNS TABLE (
  dog_id BIGINT,
  dog_name TEXT,
  booking_id BIGINT,
  booking_start_date DATE,
  booking_start_period TEXT,
  booking_end_date DATE,
  booking_end_period TEXT
)
LANGUAGE SQL
AS $$
  SELECT 
    d.id AS dog_id,
    d.name AS dog_name,
    b.id AS booking_id,
    b.start_date AS booking_start_date,
    b.start_period AS booking_start_period,
    b.end_date AS booking_end_date,
    b.end_period AS booking_end_period
  FROM 
    dogs d
  JOIN 
    bookings b ON d.id = b.dog_id
  WHERE 
    -- Booking starts within the period
    (b.start_date >= start_date AND b.start_date <= end_date)
    OR
    -- Booking ends within the period
    (b.end_date >= start_date AND b.end_date <= end_date)
    OR
    -- Booking starts before and ends after the period
    (b.start_date <= start_date AND b.end_date >= end_date);
$$; 